buildscript {
	repositories {

        maven { url "http://maven.aliyun.com/nexus/content/groups/public/" }
        maven { url "http://maven.oschina.net/content/groups/public/" }
		maven { url "http://repo.springsource.org/plugins-release" }



	}


	dependencies {
		classpath("org.springframework.build.gradle:propdeps-plugin:0.0.4")
		classpath("org.springframework.build.gradle:docbook-reference-plugin:0.2.7")
	}
}

configure(allprojects) { project ->
	group = "org.springframework"
	version = qualifyVersionIfNecessary(version)

	// The following is a work-around for allowing to build on JDK 8 until the
	// Gradle build uses Ant 1.9.x by default. This is necessary to avoid the
	// "Class not found: javac1.8" issue with Ant versions prior to 1.9.x
	ant.properties["build.compiler"] = "javac1.7"

	ext.aspectjVersion  = "1.7.2"
	ext.hsqldbVersion   = "1.8.0.10"
	ext.junitVersion    = "4.11"
	ext.slf4jVersion    = "1.6.1"
	ext.gradleScriptDir = "${rootProject.projectDir}/gradle"

	apply plugin: "propdeps"
	apply plugin: "java"
	apply plugin: "test-source-set-dependencies"
	apply from: "${gradleScriptDir}/ide.gradle"

	compileJava {
		sourceCompatibility=1.5
		targetCompatibility=1.5
	}
	compileTestJava {
		sourceCompatibility=1.7
		targetCompatibility=1.7
	}

	[compileJava, compileTestJava]*.options*.compilerArgs = [
		"-Xlint:serial",
		"-Xlint:varargs",
		"-Xlint:cast",
		"-Xlint:classfile",
		"-Xlint:dep-ann",
		"-Xlint:divzero",
		"-Xlint:empty",
		"-Xlint:finally",
		"-Xlint:overrides",
		"-Xlint:path",
		"-Xlint:processing",
		"-Xlint:static",
		"-Xlint:try",
		"-Xlint:-options",     // intentionally disabled
		"-Xlint:-fallthrough", // intentionally disabled
		"-Xlint:-rawtypes",    // TODO enable and fix warnings
		"-Xlint:-deprecation", // TODO enable and fix warnings
		"-Xlint:-unchecked"    // TODO enable and fix warnings
	]

	sourceSets.test.resources.srcDirs = ["src/test/resources", "src/test/java"]

	test {
		systemProperty("java.awt.headless", "true")
		systemProperty("testGroups", project.properties.get("testGroups"))
		scanForTestClasses = false
		include '**/*Tests.*'
		exclude '**/*Abstract*.*'
	}

	repositories {
		maven { url "http://repo.springsource.org/libs-release" }
	}

	dependencies {
		testCompile("junit:junit:${junitVersion}")
		testCompile("org.hamcrest:hamcrest-all:1.3")
		testCompile("org.mockito:mockito-core:1.9.5")
	}

	ext.javadocLinks = [
		"http://docs.oracle.com/javase/6/docs/api/",
		"http://docs.oracle.com/javaee/6/api/",
		"http://docs.oracle.com/cd/E13222_01/wls/docs90/javadocs/", // CommonJ
		"http://pic.dhe.ibm.com/infocenter/wasinfo/v7r0/topic/com.ibm.websphere.javadoc.doc/web/apidocs/",
		"http://glassfish.java.net/nonav/docs/v3/api/",
		"http://docs.jboss.org/jbossas/javadoc/4.0.5/connector/",
		"http://docs.jboss.org/jbossas/javadoc/7.1.2.Final/",
		"http://commons.apache.org/proper/commons-lang/javadocs/api-2.5/",
		"http://commons.apache.org/proper/commons-codec/apidocs/",
		"http://commons.apache.org/proper/commons-dbcp/apidocs/",
		"http://portals.apache.org/pluto/portlet-2.0-apidocs/",
		"http://tiles.apache.org/framework/apidocs/",
		"http://ibatis.apache.org/docs/java/dev/",
		"http://hc.apache.org/httpclient-3.x/apidocs/",
		"http://aopalliance.sourceforge.net/doc/",
		"http://www.eclipse.org/aspectj/doc/released/aspectj5rt-api/",
		"http://ehcache.org/apidocs/",
		"http://quartz-scheduler.org/api/2.1.5/",
		"http://jackson.codehaus.org/1.4.2/javadoc/",
		"http://fasterxml.github.com/jackson-core/javadoc/2.0.1/",
	] as String[]
}

configure(subprojects - project(":spring-build-src")) { subproject ->
	apply plugin: "merge"
	apply from: "${gradleScriptDir}/publish-maven.gradle"

	jar {
		manifest.attributes["Created-By"] =
			"${System.getProperty("java.version")} (${System.getProperty("java.specification.vendor")})"
		manifest.attributes["Implementation-Title"] = subproject.name
		manifest.attributes["Implementation-Version"] = subproject.version

		from("${rootProject.projectDir}/src/dist") {
			include "license.txt"
			include "notice.txt"
			into "META-INF"
			expand(copyright: new Date().format("yyyy"), version: project.version)
		}
	}

	javadoc {
		description = "Generates project-level javadoc for use in -javadoc jar"

		options.memberLevel = org.gradle.external.javadoc.JavadocMemberLevel.PROTECTED
		options.author = true
		options.header = project.name
		options.links(project.ext.javadocLinks)
		if(JavaVersion.current().isJava8Compatible()) {
			options.addStringOption('Xdoclint:none', '-quiet')
		}

		// suppress warnings due to cross-module @see and @link references;
		// note that global 'api' task does display all warnings.
		logging.captureStandardError LogLevel.INFO
		logging.captureStandardOutput LogLevel.INFO // suppress "## warnings" message
	}

	task sourcesJar(type: Jar, dependsOn:classes) {
		classifier = "sources"
		from sourceSets.main.allJava.srcDirs
		include "**/*.java", "**/*.aj"
	}

	task javadocJar(type: Jar) {
		classifier = "javadoc"
		from javadoc
	}

	artifacts {
		archives sourcesJar
		archives javadocJar
	}
}

project("spring-build-src") {
	description = "Exposes gradle buildSrc for IDE support"
	apply plugin: "groovy"

	dependencies {
		compile gradleApi()
		compile localGroovy()
	}

	configurations.archives.artifacts.clear()
}

project("spring-core") {
	description = "Spring Core"

	// As of Spring 3.2 spring-core repackages both asm 4.0 and cglib 3.0 and inlines both
	// into the spring-core jar. cglib 3.0 itself depends on asm 4.0, and is therefore
	// further transformed by the JarJar task to depend on org.springframework.asm; this
	// avoids including two different copies of asm unnecessarily. If however future cglib
	// versions drift from the version of asm used by Spring internally, this duplication
	// will become necessary.
	def asmVersion = "4.0"
	def cglibVersion = "3.0"

	configurations {
		jarjar
		asm
		cglib
	}

	task asmRepackJar(type: Jar) { repackJar ->
		repackJar.baseName = "spring-asm-repack"
		repackJar.version = asmVersion

		doLast() {
			project.ant {
				taskdef name: "jarjar", classname: "com.tonicsystems.jarjar.JarJarTask",
					classpath: configurations.jarjar.asPath
				jarjar(destfile: repackJar.archivePath) {
					configurations.asm.each { originalJar ->
						zipfileset(src: originalJar)
					}
					rule(pattern: "org.objectweb.asm.**", result: "org.springframework.asm.@1")
				}
			}
		}
	}

	task cglibRepackJar(type: Jar) { repackJar ->
		repackJar.baseName = "spring-cglib-repack"
		repackJar.version = cglibVersion

		doLast() {
			project.ant {
				taskdef name: "jarjar", classname: "com.tonicsystems.jarjar.JarJarTask",
					classpath: configurations.jarjar.asPath
				jarjar(destfile: repackJar.archivePath) {
					configurations.cglib.each { originalJar ->
						zipfileset(src: originalJar)
					}
					// repackage net.sf.cglib => org.springframework.cglib
					rule(pattern: "net.sf.cglib.**", result: "org.springframework.cglib.@1")
					// as mentioned above, transform cglib"s internal asm dependencies from
					// org.objectweb.asm => org.springframework.asm. Doing this counts on the
					// the fact that Spring and cglib depend on the same version of asm!
					rule(pattern: "org.objectweb.asm.**", result: "org.springframework.asm.@1")
				}
			}
		}
	}

	dependencies {
		asm("org.ow2.asm:asm:${asmVersion}@jar")
		asm("org.ow2.asm:asm-commons:${asmVersion}@jar")
		cglib("cglib:cglib:${cglibVersion}@jar")
		jarjar("com.googlecode.jarjar:jarjar:1.3")

		compile(files(cglibRepackJar))
		compile(files(asmRepackJar))
		compile("commons-logging:commons-logging:1.1.1")
		optional("org.aspectj:aspectjweaver:${aspectjVersion}")
		optional("net.sf.jopt-simple:jopt-simple:3.0")
		optional("log4j:log4j:1.2.17")
		testCompile("xmlunit:xmlunit:1.3")
		testCompile("org.codehaus.woodstox:wstx-asl:3.2.7") {
			exclude group: "stax", module: "stax-api"
		}
	}

	jar {
		// inline all repackaged asm and cglib classes directly into the spring-core jar
		dependsOn asmRepackJar
		from(zipTree(asmRepackJar.archivePath)) {
			include "org/springframework/asm/**"
		}
		dependsOn cglibRepackJar
		from(zipTree(cglibRepackJar.archivePath)) {
			include "org/springframework/cglib/**"
		}
	}
}

project("spring-beans") {
	description = "Spring Beans"

	dependencies {
		compile(project(":spring-core"))
		compile(files(project(":spring-core").cglibRepackJar))
		provided("javax.el:el-api:1.0")
		provided("javax.inject:javax.inject:1")
		testCompile("log4j:log4j:1.2.17")
	}
}

project("spring-aop") {
	description = "Spring AOP"

	dependencies {
		compile(project(":spring-core"))
		compile(files(project(":spring-core").cglibRepackJar))
		compile(project(":spring-beans"))
		compile("aopalliance:aopalliance:1.0")
		optional("com.jamonapi:jamon:2.4")
		optional("commons-pool:commons-pool:1.5.3")
		optional("org.aspectj:aspectjweaver:${aspectjVersion}")
	}
}

project("spring-expression") {
	description = "Spring Expression Language (SpEL)"

	dependencies {
		compile(project(":spring-core"))
	}
}

project("spring-instrument") {
	description = "Spring Instrument"

	jar {
		manifest.attributes["Premain-Class"] =
			"org.springframework.instrument.InstrumentationSavingAgent"
		manifest.attributes["Can-Redefine-Classes"] = "true"
		manifest.attributes["Can-Retransform-Classes"] = "true"
		manifest.attributes["Can-Set-Native-Method-Prefix"] = "false"
	}
}


project("spring-context") {
	description = "Spring Context"

	dependencies {
		optional(project(":spring-instrument"))
		compile(project(":spring-aop"))
		compile(project(":spring-beans"))
		compile(project(":spring-expression"))
		compile(project(":spring-core"))
		compile(files(project(":spring-core").cglibRepackJar))
		optional("backport-util-concurrent:backport-util-concurrent:3.0")
		optional("javax.ejb:ejb-api:3.0")
		optional("javax.inject:javax.inject:1")
		optional("org.apache.geronimo.specs:geronimo-jms_1.1_spec:1.1")
		optional("javax.persistence:persistence-api:1.0")
		optional("org.beanshell:bsh:2.0b4")
		optional("org.codehaus.groovy:groovy-all:1.8.8")
		optional("org.jruby:jruby:1.6.5.1")
		optional("joda-time:joda-time:2.1")
		optional("org.slf4j:slf4j-api:${slf4jVersion}")
		optional("javax.validation:validation-api:1.0.0.GA")
		optional("org.hibernate:hibernate-validator:4.3.0.Final")
		optional("org.aspectj:aspectjweaver:${aspectjVersion}")
		optional("org.apache.geronimo.specs:geronimo-jta_1.1_spec:1.1")
		testCompile("commons-dbcp:commons-dbcp:1.2.2")
		testCompile("javax.inject:javax.inject-tck:1")
	}

	// pick up RmiInvocationWrapperRTD.xml in src/main
	sourceSets.main.resources.srcDirs += "src/main/java"

	test {
		jvmArgs = ["-disableassertions:org.aspectj.weaver.UnresolvedType"] // SPR-7989
	}
}

project("spring-tx") {
	description = "Spring Transaction"

	dependencies {
		optional(project(":spring-context")) // for JCA, @EnableTransactionManagement
		optional(project(":spring-aop"))
		compile(project(":spring-beans"))
		compile(project(":spring-core"))
		compile("aopalliance:aopalliance:1.0")
		provided("com.ibm.websphere:uow:6.0.2.17")
		optional("javax.resource:connector-api:1.5")
		optional("org.apache.geronimo.specs:geronimo-jta_1.1_spec:1.1")
		optional("javax.ejb:ejb-api:3.0")
		testCompile("javax.persistence:persistence-api:1.0")
		testCompile("org.aspectj:aspectjweaver:${aspectjVersion}")
	}
}


project("spring-jdbc") {
	description = "Spring JDBC"

	dependencies {
		compile(project(":spring-core"))
		compile(project(":spring-beans"))
		optional(project(":spring-context")) // for JndiDataSourceLookup
		compile(project(":spring-tx"))
		optional("c3p0:c3p0:0.9.1.2")
		optional("hsqldb:hsqldb:${hsqldbVersion}")
		optional("com.h2database:h2:1.0.71")
		optional("org.apache.derby:derby:10.5.3.0_1")
		optional("org.apache.derby:derbyclient:10.5.3.0_1")
		optional("org.apache.geronimo.specs:geronimo-jta_1.1_spec:1.1")
	}
}




project("spring-test") {
	description = "Spring TestContext Framework"

	dependencies {
		compile(project(":spring-core"))
		optional(project(":spring-beans"))
		optional(project(":spring-context"))
		optional(project(":spring-jdbc"))
		optional(project(":spring-tx"))
		optional("junit:junit:${junitVersion}")
		optional("org.testng:testng:6.5.2")
		optional("javax.servlet:servlet-api:2.5")
		optional("javax.servlet.jsp:jsp-api:2.1")
		optional("javax.portlet:portlet-api:2.0")
		optional("javax.persistence:persistence-api:1.0")
		optional("org.aspectj:aspectjweaver:${aspectjVersion}")
		testCompile("org.hibernate:hibernate-core:3.3.2.GA")
		provided("javax.inject:javax.inject:1")
		provided("javax.activation:activation:1.1")
		provided("javax.servlet:jstl:1.2")
		testCompile "org.slf4j:slf4j-jcl:${slf4jVersion}"
		testCompile("hsqldb:hsqldb:${hsqldbVersion}")
	}

	task testNG(type: Test) {
		useTestNG()
		scanForTestClasses = false
		include "**/testng/*.*"
		exclude "**/FailingBeforeAndAfterMethodsTests.class"
		// "TestCase" classes are run by other test classes, not the build.
		exclude "**/*TestCase.class"
		// Generate TestNG reports alongside JUnit reports.
		testReport true
	}

	test {
		dependsOn testNG
		useJUnit()
		exclude "**/testng/*.*"
		// "TestCase" classes are run by other test classes, not the build.
		exclude(["**/*TestCase.class", "**/*TestSuite.class"])
	}

}



configure(rootProject) {
	description = "Spring Framework"

	apply plugin: "docbook-reference"
	apply plugin: "groovy"
	// apply plugin: "detect-split-packages"
	apply from: "${gradleScriptDir}/jdiff.gradle"

	reference {
		sourceDir = file("src/reference/docbook")
		pdfFilename = "spring-framework-reference.pdf"
	}

	// TODO: DetectSplitPackagesPlugin fails in line 154 due to method not found on java.io.File.
	// TODO: Possibly related to user rights or OS differences on OpenJDK 8; works fine on JDK 7.
	// detectSplitPackages {
	//	projectsToScan -= project(":spring-instrument-tomcat")
	// }

	// don't publish the default jar for the root project
	configurations.archives.artifacts.clear()

	dependencies { // for integration tests
		testCompile(project(":spring-core"))
		testCompile(project(":spring-beans"))
		testCompile(project(":spring-aop"))
		testCompile(project(":spring-expression"))
		testCompile(project(":spring-context"))
		testCompile(project(":spring-tx"))
		testCompile(project(":spring-jdbc"))
		testCompile(project(":spring-test"))
		testCompile("org.hibernate:hibernate-core:4.1.9.Final")
		testCompile("javax.servlet:servlet-api:2.5")
		testCompile("javax.portlet:portlet-api:2.0")
		testCompile("javax.inject:javax.inject:1")
		testCompile("javax.resource:connector-api:1.5")
		testCompile("org.aspectj:aspectjweaver:${aspectjVersion}")
		testCompile("hsqldb:hsqldb:${hsqldbVersion}")
	}

	task api(type: Javadoc) {
		group = "Documentation"
		description = "Generates aggregated Javadoc API documentation."
		title = "${rootProject.description} ${version} API"

		dependsOn {
			subprojects.collect {
				it.tasks.getByName("jar")
			}
		}
		options.memberLevel = org.gradle.external.javadoc.JavadocMemberLevel.PROTECTED
		options.author = true
		options.header = rootProject.description
		options.overview = "src/api/overview.html"
		options.stylesheetFile = file("src/api/stylesheet.css")
		options.splitIndex = true
		options.links(project.ext.javadocLinks)
		if(JavaVersion.current().isJava8Compatible()) {
			options.addStringOption('Xdoclint:none', '-quiet')
		}

		source subprojects.collect { project ->
			project.sourceSets.main.allJava
		}

		maxMemory = "1024m"
		destinationDir = new File(buildDir, "api")

		doFirst {
			classpath = files(
				// ensure Servlet 3.x and Hibernate 4.x have precedence on the Javadoc
				// classpath over their respective 2.5 and 3.x variants
				project(":spring-webmvc").sourceSets.main.compileClasspath.files.find { it =~ "servlet-api" },
				rootProject.sourceSets.test.compileClasspath.files.find { it =~ "hibernate-core" },
				// ensure the javadoc process can resolve types compiled from .aj sources
				project(":spring-aspects").sourceSets.main.output
			)
			classpath += files(subprojects.collect { it.sourceSets.main.compileClasspath })
		}
	}

	task docsZip(type: Zip) {
		group = "Distribution"
		baseName = "spring-framework"
		classifier = "docs"
		description = "Builds -${classifier} archive containing api and reference " +
			"for deployment at http://static.springframework.org/spring-framework/docs."

		from("src/dist") {
			include "changelog.txt"
		}

		from (api) {
			into "javadoc-api"
		}

		from (reference) {
			into "spring-framework-reference"
		}
	}

	task schemaZip(type: Zip) {
		group = "Distribution"
		baseName = "spring-framework"
		classifier = "schema"
		description = "Builds -${classifier} archive containing all " +
			"XSDs for deployment at http://springframework.org/schema."

		subprojects.each { subproject ->
			def Properties schemas = new Properties();

			subproject.sourceSets.main.resources.find {
				it.path.endsWith("META-INF/spring.schemas")
			}?.withInputStream { schemas.load(it) }

			for (def key : schemas.keySet()) {
				def shortName = key.replaceAll(/http.*schema.(.*).spring-.*/, '$1')
				assert shortName != key
				File xsdFile = subproject.sourceSets.main.resources.find {
					it.path.endsWith(schemas.get(key))
				}
				assert xsdFile != null
				into (shortName) {
					from xsdFile.path
				}
			}
		}
	}

	task distZip(type: Zip, dependsOn: [docsZip, schemaZip]) {
		group = "Distribution"
		baseName = "spring-framework"
		classifier = "dist"
		description = "Builds -${classifier} archive, containing all jars and docs, " +
					"suitable for community download page."

		ext.baseDir = "${baseName}-${project.version}";

		from("src/dist") {
			include "readme.txt"
			include "license.txt"
			include "notice.txt"
			into "${baseDir}"
			expand(copyright: new Date().format("yyyy"), version: project.version)
		}

		from(zipTree(docsZip.archivePath)) {
			into "${baseDir}/docs"
		}

		from(zipTree(schemaZip.archivePath)) {
			into "${baseDir}/schema"
		}

		subprojects.each { subproject ->
			into ("${baseDir}/libs") {
				from subproject.jar
				if (subproject.tasks.findByPath("sourcesJar")) {
					from subproject.sourcesJar
				}
				if (subproject.tasks.findByPath("javadocJar")) {
					from subproject.javadocJar
				}
			}
		}
	}

	// Create an distribution that contains all dependencies (required and optional).
	// Not published by default; only for use when building from source.
	task depsZip(type: Zip, dependsOn: distZip) { zipTask ->
		group = "Distribution"
		baseName = "spring-framework"
		classifier = "dist-with-deps"
		description = "Builds -${classifier} archive, containing everything " +
			"in the -${distZip.classifier} archive plus all runtime dependencies."

		from zipTree(distZip.archivePath)

		gradle.taskGraph.whenReady { taskGraph ->
			if (taskGraph.hasTask(":${zipTask.name}")) {
				def projectNames = rootProject.subprojects*.name
				def artifacts = new HashSet()
				subprojects.each { subproject ->
					(subproject.configurations.runtime.resolvedConfiguration.resolvedArtifacts +
					subproject.configurations.optional.resolvedConfiguration.resolvedArtifacts).each { artifact ->
						def dependency = artifact.moduleVersion.id
						if (!projectNames.contains(dependency.name)) {
							artifacts << artifact.file
						}
					}
				}

				zipTask.from(artifacts) {
					into "${distZip.baseDir}/deps"
				}
			}
		}
	}

	artifacts {
		archives docsZip
		archives schemaZip
		archives distZip
	}

	task wrapper(type: Wrapper) {
		description = "Generates gradlew[.bat] scripts"
		gradleVersion = "1.6"

		doLast() {
			def gradleOpts = "-XX:MaxPermSize=1024m -Xmx1024m"
			def gradleBatOpts = "$gradleOpts -XX:MaxHeapSize=256m"
			File wrapperFile = file("gradlew")
			wrapperFile.text = wrapperFile.text.replace("DEFAULT_JVM_OPTS=",
				"GRADLE_OPTS=\"$gradleOpts \$GRADLE_OPTS\"\nDEFAULT_JVM_OPTS=")
			File wrapperBatFile = file("gradlew.bat")
			wrapperBatFile.text = wrapperBatFile.text.replace("set DEFAULT_JVM_OPTS=",
				"set GRADLE_OPTS=$gradleBatOpts %GRADLE_OPTS%\nset DEFAULT_JVM_OPTS=")
		}
	}

}

/*
 * Support publication of artifacts versioned by topic branch.
 * CI builds supply `-P BRANCH_NAME=<TOPIC>` to gradle at build time.
 * If <TOPIC> starts with 'SPR-', change version
 *     from BUILD-SNAPSHOT => <TOPIC>-SNAPSHOT
 *     e.g. 3.2.1.BUILD-SNAPSHOT => 3.2.1.SPR-1234-SNAPSHOT
 */
def qualifyVersionIfNecessary(version) {
	if (rootProject.hasProperty("BRANCH_NAME")) {
		def qualifier = rootProject.getProperty("BRANCH_NAME")
		if (qualifier.startsWith("SPR-")) {
			return version.replace('BUILD', qualifier)
		}
	}
	return version
}
